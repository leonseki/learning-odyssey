---
title: 锁系列 01 - 锁初识
date: 2024-02-20
slug: lock/intro
image: img/2024/02/Riou.jpg
categories: [Learning]
tags: [Learning, Lock]
---


## 锁的概念

在编程中，锁（Lock）是一种同步机制，用于控制对共享资源的访问，以确保多个线程不会同时修改共享资源，从而避免数据竞争和数据不一致性问题。

锁的概念主要涉及以下几个方面：

* **互斥性（Mutual Exclusion）**：锁能够确保在任意时刻只有一个线程可以持有它。如果一个线程已经获取了锁，其他线程就无法同时获取该锁，直到持有锁的线程释放它。
* **临界区（Critical Section）**：临界区是指访问共享资源的代码段。通过使用锁来保护临界区，可以确保在任意时刻只有一个线程可以进入临界区执行，从而避免并发访问导致的数据不一致问题。
* **锁的状态**：锁通常有两种状态，即锁定（locked）和未锁定（unlocked）。当一个线程成功获取锁时，锁进入锁定状态；当线程释放锁时，锁进入未锁定状态。
* **锁的类型**：常见的锁包括互斥锁（Mutex）、读写锁（Read-Write Lock）、自旋锁（Spinlock）等。不同类型的锁具有不同的特性和适用场景。
* **死锁（Deadlock）**：死锁是指两个或多个线程互相持有对方所需要的资源，导致所有线程都无法继续执行的情况。为了避免死锁，应当遵循一定的加锁顺序或使用超时机制等方法。
* 
## 死锁

当两个（或多个）任务正在等待必须由另一个线程释放的某个资源，而该线程又正在等待必须由前述任务之一释放的另一个共享资源时，并发应用程序就出现了**死锁**。当系统同时出现如下四种情况时，
就会导致这种情形。我们称其为**Coffman条件**。

* **互斥**：死锁涉及的资源必须是不可共享的。一次只有一个任务可以使用资源。
* **占有并等待条件**：一个任务在占有某一个互斥的资源时又请求另一个互斥资源。当它在等待时，不会释放任何资源。
* **不可剥夺**：资源只能被那些持有它们的任务释放。
* **循环等待**：任务1等待任务2所占有的资源，而任务2又在等待任务3所占的资源，以此类推，最终任务n又在等待任务1所占的资源，这样就出现了循环等待。


## Java中的锁

Java中提供了丰富的锁实现，如**内置锁（Intrinsic Locks）/ synchronized 关键字**、Java并发包**java.util.concurrent**提供的**可重入锁（ReentrantLock）**、**读写锁（ReadWriteLock）** 等。
后面将把每一种都都进行详细的介绍。接下来就说明我们在学习Java中最先接触到也是最基础的锁**synchronized 关键字**。
